# Batch Triage Automation - Technical Specification

## Overview

Automated system for triaging GitHub issues synced to Linear, designed to accelerate issue burndown by performing textual analysis and recommending categorization with selective reproduction when needed.

## Problem Statement

Current manual triage workflow bottlenecks:
1. **Creating reproductions** (biggest time sink)
2. **Version upgrade testing** (second biggest)
3. Reading/understanding issues
4. Crafting custom responses

Current manual process requires ~30-60 minutes per issue for complex cases involving reproductions.

## Solution Architecture

### Phase 1: Textual Analysis & Categorization (MVP)

Batch process Linear issues with GitHub links to:
1. Extract issue metadata (client, language, SDK repo, GitHub URL)
2. Analyze issue description to determine category
3. Assess need for reproduction
4. Generate triage recommendations with confidence scores
5. Output structured results for human review

### Phase 2: Reproduction on Demand

For issues requiring verification:
- Automated reproduction setup using marvin sandbox
- Version upgrade testing in tmp directories
- Config repo cloning and isolation
- SDK generation with specific versions
- Test execution and result capture
- Version comparison (current vs latest)

---

## Critical Design Principle: Complete Isolation

**The batch-triage-tool NEVER modifies the user's development repositories or working directories.**

All operations are completely isolated from the user's development workflow at `~/git/` and `~/.frond/config-repos/`.

### Isolation Architecture

#### Tool Workspace Structure

```
~/git/marvin/packages/batch-triage-tool/
├── src/                              # Tool source code
├── workspace/                        # Tool's isolated workspace (gitignored)
│   └── jsklan-repros/               # Cloned copy for PR operations
├── config/                          # Tool configuration
└── tmp-operations/                  # Optional: local tmp tracking (gitignored)
```

#### Reproduction Isolation

All reproduction operations happen in completely isolated temporary directories:

```
/tmp/
├── triage-FER-6329/                 # Isolated test project
│   ├── package.json                 # Generated by marvin sandbox
│   ├── src/
│   │   └── reproduction.ts          # Extracted reproduction code
│   └── node_modules/                # SDK dependencies
├── triage-FER-6329-config/          # Isolated config repo clone (if needed)
│   └── fern/
│       ├── fern.config.json
│       └── apis/
└── triage-FER-7288/                 # Another isolated reproduction
    ├── requirements.txt
    ├── reproduction.py
    └── venv/
```

**Cleanup**: All `/tmp/triage-*` directories are removed after reproduction completes (success or failure).

### Directory Access Rules

#### ✅ **Read-Only Access** (Tool execution only)

| Directory | Purpose | Operations |
|-----------|---------|------------|
| `~/git/marvin/` | Execute marvin CLI | Execute commands only, no modifications |

#### ❌ **Never Accessed** (User's working directories)

| Directory | Reason |
|-----------|--------|
| `~/.frond/config-repos/` | User's working config repos - never touched |
| `~/git/fern/` | User's fern monorepo - never touched |
| `~/git/jsklan-repros/` | User's personal repro repo - only cloned to workspace |
| Any other `~/git/` repos | Completely isolated from tool operations |

#### ✅ **Write Access** (Controlled, isolated locations)

| Directory | Purpose | Operations |
|-----------|---------|------------|
| `workspace/jsklan-repros/` | Isolated clone for branching/committing | Clone, branch, commit, push via gh CLI |
| `/tmp/triage-*/` | Ephemeral reproduction environments | Create, write, execute, cleanup |

---

## Data Flow

### Phase 1: Textual Analysis
```
Linear Project Issues (with ghIssue tag)
  ↓
Extract Metadata (client, language, SDK repo, GitHub URL)
  ↓
Textual Analysis → Category Recommendation (a/b/c/d)
  ↓
Reproduction Assessment → Needed? Yes/No
  ↓
Output Triage Report (JSON/Markdown)
```

### Phase 2: Reproduction Workflow
```
Issue Flagged for Reproduction
  ↓
Parse Issue for Code Sample & SDK Version
  ↓
Create Tmp Directory (/tmp/triage-{linearId})
  ↓
Generate Test Project (marvin sandbox {language})
  ↓
Install SDK Version (from issue or timestamp)
  ↓
Execute Reproduction Code
  ↓
Capture Result (success/failure/error)
  ↓
[If needed] Test with Latest Version
  ↓
Compare Results & Generate Analysis
  ↓
Update Triage Report with Reproduction Data
  ↓
Cleanup Tmp Directory
```

---

## Issue Categorization System

### Category (a): Service Bug
**Definition**: Backend API issue outside Fern's control

**Indicators**:
- API returns unexpected status codes (500, 503)
- Rate limiting issues
- Authentication/authorization failures from server
- Data inconsistencies in API responses
- Endpoint unavailability

**Action**: Notify client, no SDK fix possible

**Example Keywords**: "server error", "API returns 500", "endpoint not available", "authentication failed from server"

---

### Category (b): User Error
**Definition**: Improper SDK usage or documentation gap

**Indicators**:
- Missing required parameters
- Incorrect method usage patterns
- Type mismatches in user code
- Configuration mistakes
- Documentation references that don't match usage

**Action**: Reply with explanation, update docs if gap exists

**Example Keywords**: "how do I", "documentation unclear", "missing parameter", "wrong type passed"

---

### Category (c): Configuration Bug
**Definition**: Issue in fern-config repo (OpenAPI spec, generators.yml)

**Indicators**:
- Generated SDK has incorrect types
- Missing endpoints/methods in SDK
- Incorrect parameter optionality
- Wrong pagination implementation
- Enum/union type mismatches with API behavior

**Action**: Update config repo, merge PR, run publish workflow

**Example Keywords**: "pagination doesn't work", "type should be optional", "missing endpoint", "enum values incorrect"

---

### Category (d): Generator/CLI Bug
**Definition**: Issue in Fern codebase (generator or CLI)

**Indicators**:
- Serialization/deserialization bugs
- Code generation errors
- SDK initialization failures
- Incorrect code patterns generated
- CLI crashes or errors

**Action**: Thank user, investigate in Fern repo, report findings

**Example Keywords**: "empty response", "serialization error", "generated code doesn't compile", "SDK initialization fails"

---

## Textual Analysis Algorithm

### 1. Metadata Extraction

```typescript
interface IssueMetadata {
  linearId: string;           // e.g., "FER-6329"
  title: string;              // Full title with tags
  client: string;             // e.g., "Intercom"
  language: string;           // e.g., "typescript"
  hasGhIssue: boolean;        // Has ghIssue tag
  githubUrl: string;          // Extracted from description
  githubRepo: string;         // e.g., "intercom/intercom-node"
  slackUrl?: string;          // Extracted from description (Slack thread link)
  sdkVersion?: string;        // If mentioned in issue
  createdAt: string;          // ISO timestamp
  description: string;        // Full issue body
}
```

### 2. Category Classification

**Decision Tree**:

```
START
├─ Contains "API returns 5XX" OR "server error" OR "endpoint unavailable"?
│  └─ YES → Category (a) Service Bug [confidence: high]
│
├─ Contains "how do I" OR "documentation" OR "example" OR "tutorial"?
│  └─ YES → Category (b) User Error [confidence: medium-high]
│
├─ Contains code snippet with user error patterns?
│  └─ YES → Category (b) User Error [confidence: medium]
│
├─ Contains "type should be" OR "missing endpoint" OR "pagination" OR "enum"?
│  └─ YES → Category (c) Config Bug [confidence: medium-high]
│
├─ Contains "serialization" OR "generated code" OR "SDK initialization"?
│  └─ YES → Category (d) Generator Bug [confidence: medium-high]
│
└─ ELSE → Requires deeper analysis [confidence: low]
```

### 3. Reproduction Need Assessment

**Needs Reproduction If**:
- Category confidence < 70%
- Issue claims "should work but doesn't" with code sample
- Version-specific behavior mentioned
- Contradicts documentation
- Multiple possible root causes

**Skip Reproduction If**:
- Clear service bug (5XX errors)
- Obvious user error (missing required params)
- Already fixed in recent version (check git history)
- Duplicate of known issue

### 4. SDK Version Detection

**Strategy**:
1. Check issue description for explicit version mention
2. If not found, use issue creation timestamp
3. Query GitHub releases for SDK repo at that timestamp
4. Use latest version before issue creation date

---

## GitHub User Authentication Strategy

The tool uses `exec_as_user` function (from `~/.shared_config`) to ensure proper GitHub authentication context:

### User Context Switching

```typescript
interface GitHubUserContext {
  customerRepos: 'fern-support';  // For interacting with customer config repos
  jsklansRepos: 'jsklan';         // For jsklan-repros PR operations
}
```

### Implementation Pattern

```typescript
class GitHubAuthManager {
  /**
   * Execute gh CLI command as specific GitHub user
   * Uses exec_as_user from user's shell config
   */
  async execAsUser(user: 'jsklan' | 'fern-support', command: string): Promise<void> {
    // This calls the user's exec_as_user function which:
    // 1. Checks current gh auth status
    // 2. Switches to target user if needed (gh auth switch --user)
    // 3. Executes the command
    // 4. Switches back to original user
    await exec(`exec_as_user ${user} "${command}"`);
  }
}

// Example usage:
class ReproRepository {
  async createPR(linearId: string, title: string, body: string): Promise<string> {
    // All jsklan-repros operations use jsklan user
    return this.githubAuth.execAsUser(
      'jsklan',
      `gh pr create --repo jsklan/jsklan-repros --title "${title}" --body "${body}"`
    );
  }
}

class ConfigRepoManager {
  async cloneCustomerRepo(client: string, targetDir: string): Promise<void> {
    const repoUrl = this.getConfigRepoUrl(client);

    // All customer config repo operations use fern-support user
    await this.githubAuth.execAsUser(
      'fern-support',
      `gh repo clone ${repoUrl} ${targetDir}`
    );
  }
}
```

### Authentication Guarantees

1. **jsklan-repros operations** → Always authenticated as `jsklan`
   - Creating PRs
   - Pushing branches
   - Listing PRs

2. **Customer config repos** → Always authenticated as `fern-support`
   - Cloning repos (to `/tmp/triage-*-config/`)
   - Fetching repo metadata
   - Reading issue information

3. **Automatic context switching** → `exec_as_user` handles it
   - Checks current user with `gh api user --jq '.login'`
   - Switches if needed with `gh auth switch --user`
   - Restores original user after operation

---

## GitHub CLI Usage Patterns

All GitHub operations use `gh` CLI, never direct git operations on remote repos:

### ✅ **Correct Patterns**

```typescript
// Clone customer config repo to tmp (as fern-support)
await execAsUser('fern-support', `gh repo clone square/square-fern-config /tmp/triage-FER-123-config`);

// Create PR in jsklan-repros (as jsklan)
await execAsUser('jsklan', `gh pr create --repo jsklan/jsklan-repros --title "..." --body "..."`);

// List PRs in jsklan-repros (as jsklan)
await execAsUser('jsklan', `gh pr list --repo jsklan/jsklan-repros`);

// Get customer GitHub issue details (as fern-support)
await execAsUser('fern-support', `gh issue view 496 --repo intercom/intercom-node --json body,title,createdAt`);
```

### ❌ **Anti-Patterns (Never Do This)**

```typescript
// WRONG - Direct git operation without gh CLI
await exec('git clone https://github.com/square/square-fern-config.git');

// WRONG - Working in user's development directory
await exec('cd ~/.frond/config-repos/square && fern generate');

// WRONG - Using user's personal jsklan-repros directly
await exec('cd ~/git/jsklan-repros && git checkout -b feature');
```

---

## Implementation Details

### Input Format

```bash
# CLI interface
triage-batch --project "Square" --output-format json
triage-batch --project "Intercom" --status backlog --output report.md
triage-batch --linear-ids FER-6329,FER-7288 --with-reproductions
```

### Output Format

```json
{
  "summary": {
    "total_issues": 40,
    "analyzed": 40,
    "categories": {
      "service_bugs": 3,
      "user_errors": 12,
      "config_bugs": 18,
      "generator_bugs": 7
    },
    "reproduction_needed": 8,
    "high_confidence": 32,
    "low_confidence": 8
  },
  "issues": [
    {
      "linearId": "FER-6329",
      "title": "[Intercom, typescript, ghIssue] pagination on search articles",
      "githubUrl": "https://github.com/intercom/intercom-node/issues/496",
      "githubRepo": "intercom/intercom-node",
      "client": "Intercom",
      "language": "typescript",
      "sdkVersion": "latest@2025-08-27",
      "category": "config_bug",
      "confidence": 0.85,
      "reasoning": "Issue describes SDK generating pagination parameters (per_page, page) that the API doesn't support. This indicates OpenAPI spec incorrectly defines pagination behavior.",
      "reproductionNeeded": true,
      "reproductionReason": "Need to verify API behavior vs SDK implementation",
      "suggestedAction": "1. Check OpenAPI spec for search articles endpoint\n2. Verify pagination parameters with Intercom API docs\n3. Update spec to use correct pagination (likely cursor-based)\n4. Regenerate SDK and test",
      "relatedIssues": [],
      "estimatedEffort": "medium"
    }
  ]
}
```

---

## Technology Stack

### Core Tools
- **Linear MCP**: Fetch issue data, update statuses
- **Sequential MCP**: Complex multi-step analysis and reasoning
- **Serena MCP**: Project memory and session persistence
- **Context7 MCP**: Fern documentation and SDK patterns
- **Marvin**: Hello-world project generation (sandbox)

### Processing Flow

```typescript
// Pseudo-code
async function batchTriage(projectName: string) {
  // 1. Fetch all open issues with ghIssue tag
  const issues = await linearMCP.listIssues({
    project: projectName,
    label: "ghIssue",
    state: "open"
  });

  // 2. Process each issue
  const results = await Promise.all(
    issues.map(issue => analyzeIssue(issue))
  );

  // 3. Generate report
  return generateTriageReport(results);
}

async function analyzeIssue(issue: LinearIssue) {
  // Extract metadata from title and description
  const metadata = extractMetadata(issue);

  // Use Sequential MCP for complex analysis
  const analysis = await sequentialMCP.analyze({
    issue: metadata,
    task: "categorize and assess reproduction need"
  });

  return {
    ...metadata,
    category: analysis.category,
    confidence: analysis.confidence,
    reasoning: analysis.reasoning,
    reproductionNeeded: analysis.needsReproduction,
    suggestedAction: analysis.actionPlan
  };
}
```

### Metadata Extraction Implementation

The `MetadataExtractor` class parses Linear issue data to extract structured information:

```typescript
class MetadataExtractor {
  /**
   * Extract all metadata from Linear issue
   */
  extract(issue: LinearIssue): IssueMetadata {
    return {
      linearId: issue.identifier,
      title: issue.title,
      client: this.extractClient(issue.title),
      language: this.extractLanguage(issue.title),
      hasGhIssue: this.hasGhIssueTag(issue),
      githubUrl: this.extractGithubUrl(issue.description),
      githubRepo: this.extractGithubRepo(issue.description),
      slackUrl: this.extractSlackUrl(issue.description),
      sdkVersion: this.extractSdkVersion(issue.description),
      createdAt: issue.createdAt,
      description: issue.description
    };
  }

  /**
   * Parse title format: "[Client, language, ghIssue] description"
   */
  private extractClient(title: string): string {
    const match = title.match(/^\[([^,]+),/);
    return match ? match[1].trim() : '';
  }

  private extractLanguage(title: string): string {
    const match = title.match(/,\s*(\w+),/);
    return match ? match[1].trim() : '';
  }

  /**
   * Extract GitHub URL from description
   * Looks for patterns like: https://github.com/org/repo/issues/123
   */
  private extractGithubUrl(description: string): string {
    const match = description.match(/https:\/\/github\.com\/[^\/]+\/[^\/]+\/issues\/\d+/);
    return match ? match[0] : '';
  }

  /**
   * Extract GitHub repo from URL
   * "https://github.com/intercom/intercom-node/issues/496" → "intercom/intercom-node"
   */
  private extractGithubRepo(description: string): string {
    const url = this.extractGithubUrl(description);
    if (!url) return '';

    const match = url.match(/github\.com\/([^\/]+\/[^\/]+)\//);
    return match ? match[1] : '';
  }

  /**
   * Extract Slack thread URL from description
   * Looks for patterns like: https://buildwithfern.slack.com/archives/CHANNEL/pTIMESTAMP
   */
  private extractSlackUrl(description: string): string | undefined {
    const match = description.match(/https:\/\/[^.]+\.slack\.com\/archives\/[A-Z0-9]+\/p\d+/);
    return match ? match[0] : undefined;
  }

  /**
   * Extract SDK version from description if explicitly mentioned
   * Patterns: "v2.1.0", "version 2.1.0", "@2.1.0"
   */
  private extractSdkVersion(description: string): string | undefined {
    const patterns = [
      /v(\d+\.\d+\.\d+)/i,
      /version\s+(\d+\.\d+\.\d+)/i,
      /@(\d+\.\d+\.\d+)/
    ];

    for (const pattern of patterns) {
      const match = description.match(pattern);
      if (match) return match[1];
    }

    return undefined;
  }

  private hasGhIssueTag(issue: LinearIssue): boolean {
    return issue.labels?.some(label => label.name === 'ghIssue') ?? false;
  }
}
```

---

## Phase 2: Reproduction System Implementation

### Overview

Phase 2 adds automated reproduction capabilities for issues that require verification. This system creates isolated test environments, executes reproduction code, and captures results.

### Marvin Integration

**Marvin Location**: `~/git/marvin`

**Purpose**: Generate hello-world projects in various languages with SDK dependencies using sandbox command

**Usage**:
```bash
# Generate TypeScript project
cd /tmp/triage-FER-6329
marvin sandbox create --language typescript --sdk-name @intercom/client

# Generate Python project
cd /tmp/triage-FER-7288
marvin sandbox create --language python --sdk-name cohere
```

**Project Structure Created**:
```
typescript/
├── package.json
├── tsconfig.json
├── src/
│   └── index.ts
└── node_modules/

python/
├── requirements.txt
├── venv/
└── main.py
```

### Marvin Integration (Correct Pattern)

Marvin creates test projects **IN** the specified directory (tmp):

```typescript
class MarvinIntegration {
  async generateTestProject(tmpDir: string, language: string): Promise<void> {
    // Marvin is executed FROM ~/git/marvin but creates project IN tmpDir
    const marvinPath = path.join(process.env.HOME!, 'git/marvin');

    // Change to tmpDir BEFORE running marvin
    await exec(`cd ${tmpDir} && ${marvinPath}/bin/marvin sandbox create --language ${language}`);

    // Result: Project files created in tmpDir, not in ~/git/marvin
  }
}
```

**Directory state after marvin execution:**

```
/tmp/triage-FER-6329/           # tmpDir (where we cd'd to)
├── package.json                 # ✅ Created by marvin IN tmpDir
├── tsconfig.json                # ✅ Created by marvin IN tmpDir
└── src/
    └── index.ts                 # ✅ Created by marvin IN tmpDir

~/git/marvin/                   # Marvin source (unchanged)
├── packages/                    # ✅ No modifications
└── templates/                   # ✅ No modifications
```

### Reproduction Orchestrator

**Core Component**: `ReproductionOrchestrator` class

**Responsibilities**:
1. Create isolated tmp directory for each issue
2. Clone config repo (if needed for version testing)
3. Generate test project with marvin sandbox
4. Install specific SDK version
5. Extract and execute reproduction code from issue
6. Capture stdout, stderr, exit code
7. Test with latest version (if version upgrade test needed)
8. Compare results
9. Clean up tmp directory

**Implementation**:

```typescript
interface ReproductionConfig {
  linearId: string;
  client: string;
  language: string;
  sdkRepo: string;
  sdkVersion: string;
  codeSnippet: string;
  testLatestVersion: boolean;
}

interface ReproductionResult {
  success: boolean;
  stdout: string;
  stderr: string;
  exitCode: number;
  executionTime: number;
  error?: string;
}

class ReproductionOrchestrator {
  private tmpDir: string;
  private config: ReproductionConfig;

  async execute(): Promise<ReproductionReport> {
    // 1. Setup
    await this.createTmpDirectory();

    // 2. Generate test project
    await this.generateTestProject();

    // 3. Install SDK at specific version
    await this.installSDK(this.config.sdkVersion);

    // 4. Execute reproduction code
    const resultV1 = await this.runReproduction();

    // 5. Test with latest version (if needed)
    let resultV2: ReproductionResult | null = null;
    if (this.config.testLatestVersion) {
      await this.installSDK('latest');
      resultV2 = await this.runReproduction();
    }

    // 6. Analyze results
    const analysis = this.analyzeResults(resultV1, resultV2);

    // 7. Cleanup
    await this.cleanup();

    return this.generateReport(resultV1, resultV2, analysis);
  }

  private async createTmpDirectory(): Promise<void> {
    this.tmpDir = `/tmp/triage-${this.config.linearId}`;
    await fs.mkdir(this.tmpDir, { recursive: true });
  }

  private async generateTestProject(): Promise<void> {
    const marvinPath = path.join(process.env.HOME!, 'git/marvin');

    // Determine SDK package name from repo
    const sdkPackage = this.getSdkPackageName();

    await exec(`cd ${this.tmpDir} && ${marvinPath}/bin/marvin sandbox create --language ${this.config.language} --sdk-name ${sdkPackage}`);
  }

  private getSdkPackageName(): string {
    // Map GitHub repo to package name
    const repoToPackage: Record<string, string> = {
      'intercom/intercom-node': '@intercom/client',
      'cohere-ai/cohere-python': 'cohere',
      'square/square-typescript-sdk': 'square',
      // ... other mappings
    };

    return repoToPackage[this.config.sdkRepo] || this.config.sdkRepo.split('/')[1];
  }

  private async installSDK(version: string): Promise<void> {
    const packageName = this.getSdkPackageName();

    if (this.config.language === 'typescript') {
      const versionSpec = version === 'latest' ? packageName : `${packageName}@${version}`;
      await exec(`cd ${this.tmpDir} && npm install ${versionSpec}`);
    } else if (this.config.language === 'python') {
      const versionSpec = version === 'latest' ? packageName : `${packageName}==${version}`;
      await exec(`cd ${this.tmpDir} && pip install ${versionSpec}`);
    }
  }

  private async runReproduction(): Promise<ReproductionResult> {
    const startTime = Date.now();

    // Write reproduction code to file
    await this.writeReproductionCode();

    try {
      const { stdout, stderr } = await exec(this.getExecutionCommand(), {
        cwd: this.tmpDir,
        timeout: 30000 // 30 second timeout
      });

      return {
        success: true,
        stdout,
        stderr,
        exitCode: 0,
        executionTime: Date.now() - startTime
      };
    } catch (error: any) {
      return {
        success: false,
        stdout: error.stdout || '',
        stderr: error.stderr || '',
        exitCode: error.code || 1,
        executionTime: Date.now() - startTime,
        error: error.message
      };
    }
  }

  private async writeReproductionCode(): Promise<void> {
    if (this.config.language === 'typescript') {
      const code = `
import { ${this.inferImports()} } from '${this.getSdkPackageName()}';

async function main() {
  ${this.config.codeSnippet}
}

main().catch(console.error);
`;
      await fs.writeFile(path.join(this.tmpDir, 'src/index.ts'), code);
    } else if (this.config.language === 'python') {
      const code = `
${this.inferImports()}

def main():
    ${this.config.codeSnippet.split('\n').join('\n    ')}

if __name__ == "__main__":
    main()
`;
      await fs.writeFile(path.join(this.tmpDir, 'main.py'), code);
    }
  }

  private inferImports(): string {
    // Analyze code snippet to infer necessary imports
    // This is a simplified version - real implementation would be more robust
    const snippet = this.config.codeSnippet;

    if (this.config.language === 'typescript') {
      // Look for client initialization patterns
      if (snippet.includes('new ') && snippet.includes('Client')) {
        return 'Client';
      }
    } else if (this.config.language === 'python') {
      if (snippet.includes('co.')) {
        return 'import cohere\nco = cohere.Client()';
      }
    }

    return ''; // Default empty imports
  }

  private getExecutionCommand(): string {
    if (this.config.language === 'typescript') {
      return 'npm run build && node dist/index.js';
    } else if (this.config.language === 'python') {
      return 'python main.py';
    }
    return '';
  }

  private analyzeResults(v1: ReproductionResult, v2: ReproductionResult | null): ReproductionAnalysis {
    const analysis: ReproductionAnalysis = {
      issueConfirmed: !v1.success,
      fixedInLatest: false,
      category: this.inferCategory(v1, v2),
      confidence: 0.8,
      reasoning: []
    };

    if (!v1.success) {
      analysis.reasoning.push('Issue reproduced with reported version');

      if (v2) {
        if (v2.success) {
          analysis.fixedInLatest = true;
          analysis.reasoning.push('Issue resolved in latest version');
          analysis.category = 'fixed';
        } else {
          analysis.reasoning.push('Issue persists in latest version');
        }
      }
    } else {
      analysis.reasoning.push('Unable to reproduce issue');
      analysis.confidence = 0.5;
    }

    return analysis;
  }

  private inferCategory(v1: ReproductionResult, v2: ReproductionResult | null): string {
    // Analyze error messages to infer category
    const stderr = v1.stderr.toLowerCase();

    if (stderr.includes('typeerror') || stderr.includes('undefined')) {
      return 'generator_bug';
    }
    if (stderr.includes('404') || stderr.includes('500')) {
      return 'service_bug';
    }
    if (stderr.includes('missing') || stderr.includes('required')) {
      return 'config_bug';
    }

    return 'unknown';
  }

  private async cleanup(): Promise<void> {
    await exec(`rm -rf ${this.tmpDir}`);
  }

  private generateReport(
    v1: ReproductionResult,
    v2: ReproductionResult | null,
    analysis: ReproductionAnalysis
  ): ReproductionReport {
    return {
      linearId: this.config.linearId,
      reproduced: analysis.issueConfirmed,
      versionTested: this.config.sdkVersion,
      latestVersionTested: v2 ? 'latest' : null,
      fixedInLatest: analysis.fixedInLatest,
      category: analysis.category,
      confidence: analysis.confidence,
      reasoning: analysis.reasoning,
      results: {
        original: v1,
        latest: v2
      }
    };
  }
}
```

### Reproduction Repository Integration

**Critical Requirement**: All reproductions must end up in the `~/git/jsklan-repros` repository with PRs created for review.

**Repository**: `~/git/jsklan-repros`

**Workflow**:
1. Clone jsklan-repros to tool workspace at startup
2. For each reproduction, create a new branch
3. Create reproduction directory structure
4. Copy reproduction artifacts (code, results, README)
5. Commit changes to branch
6. Push branch to remote
7. Create GitHub PR with reproduction details

**Branch Naming Convention**:
```
repro/FER-{linearId}-{client}-{language}

Examples:
- repro/FER-6329-intercom-typescript
- repro/FER-7288-cohere-python
```

**Directory Structure in jsklan-repros**:
```
jsklan-repros/
├── square/
│   ├── 89-types-incorrectly-wrapped/
│   │   ├── report.md                    # Auto-triage report (always)
│   │   ├── reproduction.ts              # Reproduction code (if repro done)
│   │   ├── package.json                 # Dependencies (if repro done)
│   │   └── results.json                 # Reproduction results (if repro done)
│   └── 127-serialization-delays/
│       └── report.md
├── intercom/
│   ├── 496-pagination-search-articles/
│   │   ├── report.md
│   │   ├── reproduction.ts
│   │   ├── package.json
│   │   └── results.json
│   └── 523-type-definitions/
│       └── report.md
└── cohere/
    ├── 493-empty-token-strings/
    │   ├── report.md
    │   ├── reproduction.py
    │   ├── requirements.txt
    │   └── results.json
    └── 512-streaming-issue/
        └── report.md
```

**Naming Convention**: `{gh-issue-number}-{short-description}/`
- Examples: `496-pagination-search-articles/`, `89-types-incorrectly-wrapped/`
- Short description: 2-4 words, kebab-case

### jsklan-repros Repository Integration

#### Workspace Clone (Not Direct Usage)

```typescript
class ReproRepository {
  private workspacePath: string;
  private repoPath: string;

  constructor() {
    // Tool's workspace directory
    this.workspacePath = path.join(__dirname, '../../workspace');
    this.repoPath = path.join(this.workspacePath, 'jsklan-repros');
  }

  async initialize(): Promise<void> {
    // Ensure workspace directory exists
    await exec(`mkdir -p ${this.workspacePath}`);

    // Clone jsklan-repros to workspace (not used directly from ~/git/)
    if (!fs.existsSync(this.repoPath)) {
      await this.githubAuth.execAsUser(
        'jsklan',
        `gh repo clone jsklan/jsklan-repros ${this.repoPath}`
      );
    } else {
      // Pull latest changes in workspace clone
      await exec(`cd ${this.repoPath} && git fetch origin && git checkout main && git pull`);
    }
  }

  async createReproduction(/* ... */): Promise<string> {
    // All git operations happen in workspace/jsklan-repros/
    // NOT in ~/git/jsklan-repros/

    const branchName = `repro/FER-${linearId}-${client}-${language}`;

    // Create branch in workspace clone
    await exec(`cd ${this.repoPath} && git checkout -b ${branchName}`);

    // Write artifacts
    await this.writeArtifacts(/* ... */);

    // Commit and push from workspace clone
    await exec(`cd ${this.repoPath} && git add .`);
    await exec(`cd ${this.repoPath} && git commit -m "Add reproduction for FER-${linearId}"`);
    await exec(`cd ${this.repoPath} && git push -u origin ${branchName}`);

    // Create PR using gh CLI (as jsklan user)
    const prUrl = await this.githubAuth.execAsUser(
      'jsklan',
      `cd ${this.repoPath} && gh pr create --title "${prTitle}" --body "${prBody}"`
    );

    return prUrl;
  }
}
```

#### Why Clone to Workspace?

1. **Isolation**: User's `~/git/jsklan-repros/` remains untouched
2. **Parallel Safety**: Tool can run while user works in their repo
3. **Clean State**: Each tool run starts from known state (main branch)
4. **No Conflicts**: Tool branches never interfere with user's branches

---

## Success Metrics

### Primary Goals
- **Triage time reduction**: Cut average triage time by 50%
- **Batch efficiency**: Process 20+ issues per hour (vs 2-3 manual)
- **Accuracy**: ≥80% category accuracy on high-confidence predictions

### Quality Metrics
- **High confidence threshold**: ≥70% confidence score
- **Reproduction precision**: Only flag issues truly needing reproduction
- **False positive rate**: <10% incorrect categorizations
- **Coverage**: Analyze 100% of backlog issues

---

## Project Structure

```
batch-triage-tool/
├── src/
│   ├── index.ts                     # CLI entry point
│   ├── commands/
│   │   ├── triage.ts                # Main triage command
│   │   └── repro.ts                 # Reproduction command
│   ├── core/
│   │   ├── LinearClient.ts          # Linear MCP wrapper
│   │   ├── MetadataExtractor.ts     # Extract issue metadata
│   │   ├── TextualAnalyzer.ts       # Categorization logic
│   │   ├── ConfidenceScorer.ts      # Confidence calculation
│   │   └── ReportGenerator.ts       # Output formatting
│   ├── reproduction/
│   │   ├── ReproductionOrchestrator.ts    # Main repro logic
│   │   ├── ReproRepository.ts             # jsklan-repros integration
│   │   ├── BatchReproductionManager.ts    # Parallel processing
│   │   ├── CodeExtractor.ts               # Extract code from issues
│   │   ├── SDKVersionDetector.ts          # Version detection
│   │   └── MarvinIntegration.ts           # Marvin wrapper
│   ├── types/
│   │   ├── IssueMetadata.ts
│   │   ├── ReproductionConfig.ts
│   │   ├── ReproductionResult.ts
│   │   └── TriageReport.ts
│   └── utils/
│       ├── exec.ts                  # Command execution helpers
│       ├── git.ts                   # Git operation helpers
│       └── logger.ts                # Logging utilities
├── tests/
│   ├── unit/
│   │   ├── TextualAnalyzer.test.ts
│   │   ├── CodeExtractor.test.ts
│   │   └── SDKVersionDetector.test.ts
│   └── integration/
│       ├── reproduction.test.ts
│       └── end-to-end.test.ts
├── config/
│   ├── clients.json                 # Client configurations
│   └── sdk-mappings.json            # GitHub repo → package name
├── workspace/                       # Tool workspace (gitignored)
│   └── jsklan-repros/              # Cloned repro repo
├── package.json
├── tsconfig.json
├── .gitignore
└── README.md
```

## Configuration Files

### config/clients.json
```json
{
  "square": {
    "linearProject": "[Square] Enterprise Support",
    "configRepo": "https://github.com/square/square-fern-config.git",
    "languages": ["typescript", "python", "java", "ruby", "php", "csharp"]
  },
  "intercom": {
    "linearProject": "[Intercom] Enterprise Support",
    "configRepo": "https://github.com/intercom/Intercom-OpenAPI.git",
    "languages": ["typescript", "java", "python", "php"]
  },
  "cohere": {
    "linearProject": "[Cohere] Enterprise Support",
    "configRepo": "https://github.com/cohere-ai/fern-cohere.git",
    "languages": ["python", "typescript", "java", "go"]
  },
  "elevenlabs": {
    "linearProject": "[ElevenLabs] Enterprise Support",
    "configRepo": "https://github.com/elevenlabs/elevenlabs-docs.git",
    "languages": ["python", "typescript"],
    "note": "GH resolution not in contract - lower priority"
  }
}
```

### config/sdk-mappings.json
```json
{
  "intercom/intercom-node": {
    "packageName": "@intercom/client",
    "language": "typescript",
    "packageManager": "npm"
  },
  "cohere-ai/cohere-python": {
    "packageName": "cohere",
    "language": "python",
    "packageManager": "pip"
  },
  "square/square-typescript-sdk": {
    "packageName": "square",
    "language": "typescript",
    "packageManager": "npm"
  },
  "square/square-python-sdk": {
    "packageName": "squareup",
    "language": "python",
    "packageManager": "pip"
  }
}
```

## Implementation Phases

### Phase 1: Textual Analysis MVP
**Estimated Time**: 1-2 days

**Deliverables**:
- [x] Project setup with TypeScript + Linear MCP integration
- [ ] Implement `MetadataExtractor` class
- [ ] Implement `TextualAnalyzer` class
- [ ] Implement `ConfidenceScorer` class
- [ ] Implement `ReportGenerator` class
- [ ] CLI command: `triage-batch --project "Square"`
- [ ] Test on 10-20 real issues from each client

**Acceptance Criteria**:
- Successfully categorize issues with ≥70% accuracy on known issues
- Generate structured reports in JSON and Markdown
- Process entire Square backlog (~40 issues) in <5 minutes

### Phase 2: Reproduction Automation
**Estimated Time**: 3-4 days

**Deliverables**:
- [ ] Implement `ReproductionOrchestrator` class
- [ ] Implement `MarvinIntegration` class
- [ ] Implement `CodeExtractor` class
- [ ] Implement `SDKVersionDetector` class
- [ ] Implement `ReproRepository` class
- [ ] Implement `BatchReproductionManager` class
- [ ] CLI command: `triage-batch --project "Cohere" --with-reproductions`
- [ ] Test on 5-10 issues requiring reproduction

**Acceptance Criteria**:
- Successfully reproduce ≥80% of issues with code snippets
- All reproductions appear in jsklan-repros with PRs
- Parallel processing completes 3 reproductions in ~2 minutes
- Tmp directories cleaned up after each reproduction
- No git conflicts or push failures

## Safety Guarantees

### File System Boundaries

```typescript
// Safe operations (within isolation boundaries)
const safePaths = [
  '/tmp/triage-*',                                    // ✅ Reproduction tmp directories
  '~/git/marvin/packages/batch-triage-tool/workspace/', // ✅ Tool workspace
];

// Read-only operations (for CLI execution)
const readOnlyPaths = [
  '~/git/marvin/bin/marvin',                          // ✅ Execute marvin CLI
];

// Never accessed (user's working directories)
const forbiddenPaths = [
  '~/.frond/config-repos/',                           // ❌ User's config repos
  '~/git/fern/',                                      // ❌ User's fern monorepo
  '~/git/jsklan-repros/',                            // ❌ User's personal repo (use workspace clone)
  '~/git/*/`',                                        // ❌ Any other git repos
];
```

### Process Isolation

1. **Separate tmp directories** for each reproduction
2. **No shared state** between reproductions
3. **Parallel execution** safe (3 concurrent reproductions don't interfere)
4. **Clean environment** for each test
5. **Workspace clone** for jsklan-repros operations

### Cleanup Guarantees

```typescript
class ReproductionOrchestrator {
  async execute(): Promise<ReproductionReport> {
    const tmpDir = `/tmp/triage-${this.config.linearId}`;

    try {
      // Setup and run reproduction
      await this.setupReproduction(tmpDir);
      const result = await this.runReproduction(tmpDir);

      // Copy artifacts to workspace jsklan-repros
      await this.reproRepo.createReproduction(/* ... */);

      return result;
    } finally {
      // ALWAYS cleanup tmp directory, even on error
      await exec(`rm -rf ${tmpDir}`);

      // Also cleanup any tmp config repos
      await exec(`rm -rf ${tmpDir}-config`);
    }
  }
}
```

---

## Setup Instructions

### Prerequisites
```bash
# System requirements
- Node.js 18+
- TypeScript 5+
- npm or pnpm
- gh CLI installed and authenticated
- Linear API key (via MCP)
- Access to ~/git/marvin
- Access to ~/git/jsklan-repros
```

### Installation
```bash
# Clone the project
git clone <repo-url> batch-triage-tool
cd batch-triage-tool

# Install dependencies
npm install

# Build TypeScript
npm run build

# Link CLI globally (optional)
npm link
```

### Configuration
```bash
# Ensure Linear MCP is configured
# Verify access to required repos
ls ~/git/marvin
ls ~/git/jsklan-repros

# Configure gh CLI
gh auth status

# Create workspace directory
mkdir -p workspace
```

### Usage Examples

**Phase 1 - Textual Analysis Only**:
```bash
# Analyze all open issues in Square project
triage-batch --project "Square" --output report.json

# Analyze specific issues
triage-batch --linear-ids FER-6329,FER-7288 --output report.md

# Analyze with filtering
triage-batch --project "Intercom" --status backlog --confidence-min 0.7
```

**Phase 2 - With Reproductions**:
```bash
# Run full triage with reproductions
triage-batch --project "Cohere" --with-reproductions

# Only reproduce specific issues
triage-batch --linear-ids FER-7288 --reproduce-only

# Batch process all clients
triage-batch --clients square,intercom,cohere --with-reproductions --parallel
```

**Output Locations**:
- **All outputs**: `~/git/jsklan-repros/{client}/{gh-issue#}-{slug}/`
  - `report.md` - Auto-triage analysis (always created)
  - `reproduction.{ts|py}` - Reproduction code (if repro performed)
  - Results and dependencies (if repro performed)
- **PRs**: Created in jsklan-repros repository
- **Summary**: `~/git/jsklan-repros/summary-{date}.md` (optional batch summary)

---

## Verification Commands

To verify the tool maintains proper isolation, the user can check:

```bash
# Should show NO modifications
git -C ~/.frond/config-repos/square status

# Should show NO modifications
git -C ~/git/jsklan-repros status

# Should show NO modifications to any other repos
git -C ~/git/fern status

# Should show tool workspace clone (expected)
ls ~/git/marvin/packages/batch-triage-tool/workspace/jsklan-repros/

# Should show cleanup (no tmp directories remaining)
ls /tmp/triage-*  # Should return "No such file or directory"
```

---

## Summary

This specification provides a complete, implementation-ready design for a batch triage automation tool that will:

1. **Analyze** all open Linear issues for Square, Intercom, and Cohere
2. **Categorize** issues into service bugs, user errors, config bugs, or generator bugs
3. **Reproduce** issues automatically when needed, running multiple reproductions in parallel
4. **Create PRs** in `~/git/jsklan-repros` with complete reproduction artifacts
5. **Reduce triage time** by 50% through automation

The tool is completely isolated from user development workflows and uses marvin sandbox for test project generation.

**Key Features**:
- ✅ Textual analysis with confidence scoring
- ✅ Automated reproduction with version testing
- ✅ Parallel processing (3 concurrent reproductions)
- ✅ Git/PR automation via gh CLI
- ✅ Complete isolation from user workflows
- ✅ Comprehensive error handling and cleanup
- ✅ Production-ready CLI interface

**Ready for Implementation**: This spec contains everything needed to build the tool from scratch, including file structure, class implementations, configuration files, setup instructions, and complete Phase 1 & 2 deliverables.
