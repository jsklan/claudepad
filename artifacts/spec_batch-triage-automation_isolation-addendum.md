# Batch Triage Automation - Isolation Architecture Addendum

## Critical Design Principle: Complete Isolation

**The batch-triage-tool NEVER modifies the user's development repositories or working directories.**

All operations are completely isolated from the user's development workflow at `~/git/` and `~/.frond/config-repos/`.

---

## Isolation Architecture

### Tool Workspace Structure

```
~/git/marvin/packages/batch-triage-tool/
├── src/                              # Tool source code
├── workspace/                        # Tool's isolated workspace (gitignored)
│   └── jsklan-repros/               # Cloned copy for PR operations
├── config/                          # Tool configuration
└── tmp-operations/                  # Optional: local tmp tracking (gitignored)
```

### Reproduction Isolation

All reproduction operations happen in completely isolated temporary directories:

```
/tmp/
├── triage-FER-6329/                 # Isolated test project
│   ├── package.json                 # Generated by marvin
│   ├── src/
│   │   └── reproduction.ts          # Extracted reproduction code
│   └── node_modules/                # SDK dependencies
├── triage-FER-6329-config/          # Isolated config repo clone (if needed)
│   └── fern/
│       ├── fern.config.json
│       └── apis/
└── triage-FER-7288/                 # Another isolated reproduction
    ├── requirements.txt
    ├── reproduction.py
    └── venv/
```

**Cleanup**: All `/tmp/triage-*` directories are removed after reproduction completes (success or failure).

---

## Directory Access Rules

### ✅ **Read-Only Access** (Tool execution only)

| Directory | Purpose | Operations |
|-----------|---------|------------|
| `~/git/frond/` | Execute frond CLI | Execute commands only, no modifications |
| `~/git/marvin/` | Execute marvin CLI | Execute commands only, no modifications |

### ❌ **Never Accessed** (User's working directories)

| Directory | Reason |
|-----------|--------|
| `~/.frond/config-repos/` | User's working config repos - never touched |
| `~/git/fern/` | User's fern monorepo - never touched |
| `~/git/jsklan-repros/` | User's personal repro repo - only cloned to workspace |
| Any other `~/git/` repos | Completely isolated from tool operations |

### ✅ **Write Access** (Controlled, isolated locations)

| Directory | Purpose | Operations |
|-----------|---------|------------|
| `workspace/jsklan-repros/` | Isolated clone for branching/committing | Clone, branch, commit, push via gh CLI |
| `/tmp/triage-*/` | Ephemeral reproduction environments | Create, write, execute, cleanup |

---

## GitHub User Authentication Strategy

The tool uses `exec_as_user` function (from `~/.shared_config`) to ensure proper GitHub authentication context:

### User Context Switching

```typescript
interface GitHubUserContext {
  customerRepos: 'fern-support';  // For interacting with customer config repos
  jsklansRepos: 'jsklan';         // For jsklan-repros PR operations
}
```

### Implementation Pattern

```typescript
class GitHubAuthManager {
  /**
   * Execute gh CLI command as specific GitHub user
   * Uses exec_as_user from user's shell config
   */
  async execAsUser(user: 'jsklan' | 'fern-support', command: string): Promise<void> {
    // This calls the user's exec_as_user function which:
    // 1. Checks current gh auth status
    // 2. Switches to target user if needed (gh auth switch --user)
    // 3. Executes the command
    // 4. Switches back to original user
    await exec(`exec_as_user ${user} "${command}"`);
  }
}

// Example usage:
class ReproRepository {
  async createPR(linearId: string, title: string, body: string): Promise<string> {
    // All jsklan-repros operations use jsklan user
    return this.githubAuth.execAsUser(
      'jsklan',
      `gh pr create --repo jsklan/jsklan-repros --title "${title}" --body "${body}"`
    );
  }
}

class ConfigRepoManager {
  async cloneCustomerRepo(client: string, targetDir: string): Promise<void> {
    const repoUrl = this.getConfigRepoUrl(client);

    // All customer config repo operations use fern-support user
    await this.githubAuth.execAsUser(
      'fern-support',
      `gh repo clone ${repoUrl} ${targetDir}`
    );
  }
}
```

### Authentication Guarantees

1. **jsklan-repros operations** → Always authenticated as `jsklan`
   - Creating PRs
   - Pushing branches
   - Listing PRs

2. **Customer config repos** → Always authenticated as `fern-support`
   - Cloning repos (to `/tmp/triage-*-config/`)
   - Fetching repo metadata
   - Reading issue information

3. **Automatic context switching** → `exec_as_user` handles it
   - Checks current user with `gh api user --jq '.login'`
   - Switches if needed with `gh auth switch --user`
   - Restores original user after operation

---

## GitHub CLI Usage Patterns

All GitHub operations use `gh` CLI, never direct git operations on remote repos:

### ✅ **Correct Patterns**

```typescript
// Clone customer config repo to tmp (as fern-support)
await execAsUser('fern-support', `gh repo clone square/square-fern-config /tmp/triage-FER-123-config`);

// Create PR in jsklan-repros (as jsklan)
await execAsUser('jsklan', `gh pr create --repo jsklan/jsklan-repros --title "..." --body "..."`);

// List PRs in jsklan-repros (as jsklan)
await execAsUser('jsklan', `gh pr list --repo jsklan/jsklan-repros`);

// Get customer GitHub issue details (as fern-support)
await execAsUser('fern-support', `gh issue view 496 --repo intercom/intercom-node --json body,title,createdAt`);
```

### ❌ **Anti-Patterns (Never Do This)**

```typescript
// WRONG - Uses user's ~/.frond/config-repos/
await exec('frond clone intercom');

// WRONG - Direct git operation without gh CLI
await exec('git clone https://github.com/square/square-fern-config.git');

// WRONG - Working in user's development directory
await exec('cd ~/.frond/config-repos/square && fern generate');

// WRONG - Using user's personal jsklan-repros directly
await exec('cd ~/git/jsklan-repros && git checkout -b feature');
```

---

## Frond and Config Repo Isolation

### Config Repo Cloning Strategy

**When config repos are needed** (e.g., for version testing or SDK generation):

```typescript
class ConfigRepoManager {
  async cloneToTmp(client: string, linearId: string): Promise<string> {
    const tmpConfigDir = `/tmp/triage-${linearId}-config`;
    const repoUrl = this.getConfigRepoUrl(client);

    // Clone via gh CLI as fern-support user
    await this.githubAuth.execAsUser(
      'fern-support',
      `gh repo clone ${repoUrl} ${tmpConfigDir}`
    );

    return tmpConfigDir;
  }

  private getConfigRepoUrl(client: string): string {
    // Map client to GitHub repo
    const configRepos: Record<string, string> = {
      'square': 'square/square-fern-config',
      'intercom': 'intercom/Intercom-OpenAPI',
      'cohere': 'cohere-ai/fern-cohere',
    };

    return configRepos[client];
  }
}
```

### Frond Usage Pattern

**Frond is NOT used in this tool.** All operations use direct `gh` CLI and SDK installation:

```typescript
// OLD SPEC (using frond) - DO NOT USE
await exec('frond clone intercom');  // ❌ Wrong - touches ~/.frond/

// CORRECT PATTERN (using gh + direct SDK installation)
class ReproductionOrchestrator {
  async setupReproduction(config: ReproductionConfig): Promise<void> {
    const tmpDir = `/tmp/triage-${config.linearId}`;

    // 1. Create isolated tmp directory
    await exec(`mkdir -p ${tmpDir}`);

    // 2. Generate test project with marvin (creates IN tmpDir)
    await exec(`cd ${tmpDir} && ~/git/marvin/bin/marvin create --language ${config.language}`);

    // 3. Install SDK at specific version
    if (config.language === 'typescript') {
      await exec(`cd ${tmpDir} && npm install ${config.sdkPackage}@${config.sdkVersion}`);
    } else if (config.language === 'python') {
      await exec(`cd ${tmpDir} && pip install ${config.sdkPackage}==${config.sdkVersion}`);
    }

    // 4. Write reproduction code
    await this.writeReproductionCode(tmpDir, config.codeSnippet);

    // 5. Execute and capture results
    const result = await this.executeReproduction(tmpDir);

    // 6. Cleanup tmp directory
    await exec(`rm -rf ${tmpDir}`);
  }
}
```

**If config repo access is absolutely needed** (rare case for testing config changes):

```typescript
class ConfigBugTester {
  async testConfigFix(config: ReproductionConfig): Promise<void> {
    // Clone config repo to tmp (NOT ~/.frond/)
    const tmpConfig = await this.configManager.cloneToTmp(
      config.client,
      config.linearId
    );

    // Make proposed config changes in tmp
    await this.applyConfigFix(tmpConfig, config.proposedFix);

    // Generate SDK with modified config using fern CLI directly
    await exec(`cd ${tmpConfig} && fern generate --group ${config.language} --local`);

    // Test with generated SDK
    const result = await this.runReproduction(tmpConfig);

    // Cleanup
    await exec(`rm -rf ${tmpConfig}`);
  }
}
```

---

## Marvin Integration (Correct Pattern)

Marvin creates test projects **IN** the specified directory (tmp):

```typescript
class MarvinIntegration {
  async generateTestProject(tmpDir: string, language: string): Promise<void> {
    // Marvin is executed FROM ~/git/marvin but creates project IN tmpDir
    const marvinPath = path.join(process.env.HOME!, 'git/marvin');

    // Change to tmpDir BEFORE running marvin
    await exec(`cd ${tmpDir} && ${marvinPath}/bin/marvin create --language ${language}`);

    // Result: Project files created in tmpDir, not in ~/git/marvin
  }
}
```

**Directory state after marvin execution:**

```
/tmp/triage-FER-6329/           # tmpDir (where we cd'd to)
├── package.json                 # ✅ Created by marvin IN tmpDir
├── tsconfig.json                # ✅ Created by marvin IN tmpDir
└── src/
    └── index.ts                 # ✅ Created by marvin IN tmpDir

~/git/marvin/                   # Marvin source (unchanged)
├── packages/                    # ✅ No modifications
└── templates/                   # ✅ No modifications
```

---

## jsklan-repros Repository Integration

### Workspace Clone (Not Direct Usage)

```typescript
class ReproRepository {
  private workspacePath: string;
  private repoPath: string;

  constructor() {
    // Tool's workspace directory
    this.workspacePath = path.join(__dirname, '../../workspace');
    this.repoPath = path.join(this.workspacePath, 'jsklan-repros');
  }

  async initialize(): Promise<void> {
    // Ensure workspace directory exists
    await exec(`mkdir -p ${this.workspacePath}`);

    // Clone jsklan-repros to workspace (not used directly from ~/git/)
    if (!fs.existsSync(this.repoPath)) {
      await this.githubAuth.execAsUser(
        'jsklan',
        `gh repo clone jsklan/jsklan-repros ${this.repoPath}`
      );
    } else {
      // Pull latest changes in workspace clone
      await exec(`cd ${this.repoPath} && git fetch origin && git checkout main && git pull`);
    }
  }

  async createReproduction(/* ... */): Promise<string> {
    // All git operations happen in workspace/jsklan-repros/
    // NOT in ~/git/jsklan-repros/

    const branchName = `repro/FER-${linearId}-${client}-${language}`;

    // Create branch in workspace clone
    await exec(`cd ${this.repoPath} && git checkout -b ${branchName}`);

    // Write artifacts
    await this.writeArtifacts(/* ... */);

    // Commit and push from workspace clone
    await exec(`cd ${this.repoPath} && git add .`);
    await exec(`cd ${this.repoPath} && git commit -m "Add reproduction for FER-${linearId}"`);
    await exec(`cd ${this.repoPath} && git push -u origin ${branchName}`);

    // Create PR using gh CLI (as jsklan user)
    const prUrl = await this.githubAuth.execAsUser(
      'jsklan',
      `cd ${this.repoPath} && gh pr create --title "${prTitle}" --body "${prBody}"`
    );

    return prUrl;
  }
}
```

### Why Clone to Workspace?

1. **Isolation**: User's `~/git/jsklan-repros/` remains untouched
2. **Parallel Safety**: Tool can run while user works in their repo
3. **Clean State**: Each tool run starts from known state (main branch)
4. **No Conflicts**: Tool branches never interfere with user's branches

---

## Safety Guarantees

### File System Boundaries

```typescript
// Safe operations (within isolation boundaries)
const safePaths = [
  '/tmp/triage-*',                                    // ✅ Reproduction tmp directories
  '~/git/marvin/packages/batch-triage-tool/workspace/', // ✅ Tool workspace
];

// Read-only operations (for CLI execution)
const readOnlyPaths = [
  '~/git/marvin/bin/marvin',                          // ✅ Execute marvin CLI
  '~/git/frond/bin/frond',                            // ✅ Execute frond CLI (if needed)
];

// Never accessed (user's working directories)
const forbiddenPaths = [
  '~/.frond/config-repos/',                           // ❌ User's config repos
  '~/git/fern/',                                      // ❌ User's fern monorepo
  '~/git/jsklan-repros/',                            // ❌ User's personal repo (use workspace clone)
  '~/git/*/`',                                        // ❌ Any other git repos
];
```

### Process Isolation

1. **Separate tmp directories** for each reproduction
2. **No shared state** between reproductions
3. **Parallel execution** safe (3 concurrent reproductions don't interfere)
4. **Clean environment** for each test
5. **Workspace clone** for jsklan-repros operations

### Cleanup Guarantees

```typescript
class ReproductionOrchestrator {
  async execute(): Promise<ReproductionReport> {
    const tmpDir = `/tmp/triage-${this.config.linearId}`;

    try {
      // Setup and run reproduction
      await this.setupReproduction(tmpDir);
      const result = await this.runReproduction(tmpDir);

      // Copy artifacts to workspace jsklan-repros
      await this.reproRepo.createReproduction(/* ... */);

      return result;
    } finally {
      // ALWAYS cleanup tmp directory, even on error
      await exec(`rm -rf ${tmpDir}`);

      // Also cleanup any tmp config repos
      await exec(`rm -rf ${tmpDir}-config`);
    }
  }
}
```

---

## Updated Implementation Checklist

### Phase 1: Textual Analysis (No File System Concerns)
- ✅ All operations via Linear MCP and GitHub MCP
- ✅ No file system operations required
- ✅ Results written to workspace/jsklan-repros/ only

### Phase 2: Reproduction Automation
- ✅ **Before any operation**: Ensure workspace/jsklan-repros/ clone exists
- ✅ **For each reproduction**: Create `/tmp/triage-{linearId}/`
- ✅ **Use marvin**: Execute from `~/git/marvin/bin/marvin` with `cd` to tmpDir first
- ✅ **SDK installation**: Install directly in tmpDir via npm/pip
- ✅ **Config repos** (if needed): Clone to `/tmp/triage-{linearId}-config/` via gh CLI
- ✅ **Never use frond**: Use gh CLI + direct SDK installation instead
- ✅ **Results**: Write to workspace/jsklan-repros/, NOT ~/git/jsklan-repros/
- ✅ **Cleanup**: Always remove `/tmp/triage-*` directories
- ✅ **GitHub auth**: Use exec_as_user for proper user context

### GitHub Authentication
- ✅ **jsklan-repros PRs**: exec_as_user jsklan "gh pr create ..."
- ✅ **Customer repos**: exec_as_user fern-support "gh repo clone ..."
- ✅ **Issue metadata**: exec_as_user fern-support "gh issue view ..."

---

## Example: Complete Reproduction Flow with Isolation

```typescript
async function reproduceIssue(issue: IssueMetadata): Promise<ReproductionReport> {
  const linearId = issue.linearId;
  const tmpDir = `/tmp/triage-${linearId}`;

  // 1. Initialize workspace (one-time per tool run)
  const reproRepo = new ReproRepository();
  await reproRepo.initialize(); // Clones to workspace/jsklan-repros/

  // 2. Create isolated tmp directory
  await exec(`mkdir -p ${tmpDir}`);

  try {
    // 3. Generate test project with marvin (creates IN tmpDir)
    await exec(`cd ${tmpDir} && ~/git/marvin/bin/marvin create --language ${issue.language}`);

    // 4. Install SDK at specific version
    const sdkPackage = getSdkPackageName(issue.githubRepo);
    const sdkVersion = await detectVersion(issue);
    await exec(`cd ${tmpDir} && npm install ${sdkPackage}@${sdkVersion}`);

    // 5. Write reproduction code
    await writeFile(`${tmpDir}/src/reproduction.ts`, issue.codeSnippet);

    // 6. Execute reproduction
    const result = await exec(`cd ${tmpDir} && npm run build && node dist/reproduction.js`);

    // 7. Create artifacts in workspace/jsklan-repros/ (NOT ~/git/jsklan-repros/)
    const prUrl = await reproRepo.createReproduction(
      linearId,
      issue.client,
      issue.language,
      {
        code: issue.codeSnippet,
        results: result,
        // ... other artifacts
      }
    );

    return {
      linearId,
      reproduced: !result.success,
      prUrl,
      // ... other fields
    };

  } finally {
    // 8. ALWAYS cleanup tmp directory
    await exec(`rm -rf ${tmpDir}`);
  }
}
```

---

## Verification Commands

To verify the tool maintains proper isolation, the user can check:

```bash
# Should show NO modifications
git -C ~/.frond/config-repos/square status

# Should show NO modifications
git -C ~/git/jsklan-repros status

# Should show NO modifications to any other repos
git -C ~/git/fern status

# Should show tool workspace clone (expected)
ls ~/git/marvin/packages/batch-triage-tool/workspace/jsklan-repros/

# Should show cleanup (no tmp directories remaining)
ls /tmp/triage-*  # Should return "No such file or directory"
```

---

## Summary of Changes from Original Spec

### ❌ **Removed/Changed:**
1. Direct usage of `~/git/jsklan-repros/` → Use workspace clone instead
2. Frond commands (`frond clone`, `frond generate`) → Use gh CLI + direct SDK installation
3. Config repos in `~/.frond/config-repos/` → Clone to `/tmp/triage-*-config/` via gh CLI
4. Direct git operations → Use gh CLI with exec_as_user

### ✅ **Added:**
1. **exec_as_user** integration for GitHub authentication
2. **Workspace directory** for jsklan-repros clone
3. **gh CLI usage** for all GitHub operations
4. **Explicit isolation boundaries** and forbidden paths
5. **Config repo cloning to tmp** instead of using ~/.frond/
6. **User context switching** (jsklan vs fern-support)

### ✅ **Confirmed:**
1. Marvin usage is already safe (creates in tmpDir)
2. Tmp directory cleanup is already specified
3. Parallel execution safety is already designed
